@page "/localgame"
@page "/localgame/{dimensions}"
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using Newtonsoft.Json
@using Newtonsoft.Json.Linq
@using Shared.Models
@using System.Collections;
@inject NavigationManager NavMan  
@inject IJSRuntime jsRuntime

<div class="turn-options inline">
    <div class="inline" id="turn-div" style="width: 90px;">Black's Turn</div>
    <button @onclick="SkipTurn" class="inline">Pass</button>
</div>
<div style="display: flex; justify-content: center; align-items: center; height: auto;">
    @if (dimensions.Equals("19"))
    {
        <div @ref="divCanvas" @onclick="@(async (MouseEventArgs m) => await OnClick(m))" class="board-canvas-19">
            <BECanvas @ref="stones" Height="620" Width="620"></BECanvas>
        </div>
    }
    @if (dimensions.Equals("13"))
    {
        <div @ref="divCanvas" @onclick="@(async (MouseEventArgs m) => await OnClick(m))" class="board-canvas-13">
            <BECanvas @ref="stones" Height="440" Width="440"></BECanvas>
        </div>
    }
    @if (dimensions.Equals("9"))
    {
        <div @ref="divCanvas" @onclick="@(async (MouseEventArgs m) => await OnClick(m))" class="board-canvas-9">
            <BECanvas @ref="stones" Height="320" Width="320"></BECanvas>
        </div>
    }
    
    <div class="@(gameOverClass)">
        <div class="modal fade show d-block" id="login" tabindex="-1" role="dialog">
            <div class="modal-dialog" role="document">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="titleLabel">Game Over</h5>
                        <button type="button" class="close" @onclick="Close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">×</span>
                        </button>
                    </div>
                    @if (go.score[0] > go.score[1])
                    {
                        <div>Black Wins</div>
                    }
                    @if (go.score[0] < go.score[1])
                    {
                        <div>White Wins</div>;
                    }
                    @if (go.score[0] == go.score[1])
                    {
                        <div>Draw!</div>
                    }
                    <button type="button" @onclick="Reset">RESET</button>

                </div>
            </div>
        </div>
    </div>
</div>
<div>
    <div class="inline">Black's Score: </div>
    <input class="inline" @bind="go.score[0]" />
</div>
<div>
    <div class="inline">White's Score: </div>
    <input class="inline" @bind="go.score[1]" />
</div>
<br>
<br>

@code {
    [Parameter]
    public String dimensions { get; set; }
    public static NavigationManager NavMan2;
    int dim;
    ElementReference divCanvas;
    Blazor.Extensions.BECanvasComponent stones;
    Canvas2DContext currentCanvasContext;
    List<Move> moves = new List<Move>();
    bool whiteTurn = false;
    ArrayList thisCaptured = new ArrayList();
    int passesInARow = 0;
    bool gameOver = false;
    string gameOverClass = "hidden";
    bool isLoadingOnClick = false;

    Board go;

    protected override async Task OnInitializedAsync()
    {
        dim = Int32.Parse(dimensions);
        go = new Board(dim);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        dim = Int32.Parse(dimensions);
        NavMan2 = NavMan;
        currentCanvasContext = await stones.CreateCanvas2DAsync();
    }

    class Move
    {
        public int row;
        public int col;
        public bool isWhite;
    }


    private void Close()
    {
        gameOverClass= "hidden";
    }

    private void Reset()
    {
        NavMan2.NavigateTo(NavMan2.Uri, forceLoad: true);
        Close();
    }

    async void SkipTurn()
    {
        passesInARow++;
        whiteTurn = !whiteTurn;
        go.skip();
        await jsRuntime.InvokeAsync<string>("setTurnIsWhite", new object[] { whiteTurn });

        if (passesInARow >= 2)
        {
            go.setPlayable(false);
            gameOver = true;
            gameOverClass = "";
        }
    }

    Move GetMove(double mouseX, double mouseY)
    {
        for (int i = 0; i < dim; i++)
        {
            for (int j = 0; j < dim; j++)
            {
                int x = (i * 30) + 40;
                int y = (j * 30) + 40;
                if (mouseX < x + 10 && mouseX > x - 10 && mouseY < y + 10 && mouseY > y - 10)
                {
                    return new Move { row = i, col = j, isWhite = whiteTurn };
                }
            }
        }
        return null;
    }

    bool IsLegalMove(Move move)
    {
        int color = -1;
        if (go.getBlackToPlay())
        {
            color = 1;
        }
        ArrayList captured = go.playMove(new int[] { move.row, move.col, color });

        if (captured == null)
        {
            return false;
        }
        else
        {
            thisCaptured = captured;
            passesInARow = 0;
            return true;
        }
    }

    async Task DrawStone(Move move)
    {
        if (move.isWhite)
        {
            await currentCanvasContext.SetFillStyleAsync("White");

        }
        else
        {
            await currentCanvasContext.SetFillStyleAsync("Black");
        }
        await currentCanvasContext.BeginPathAsync();
        await currentCanvasContext.ArcAsync(move.row * 30 + 40, move.col * 30 + 40, 10, 0, 2 * Math.PI);
        await currentCanvasContext.ClosePathAsync();
        await currentCanvasContext.FillAsync();

    }

    async Task RemoveStones()
    {
        if (thisCaptured != null || thisCaptured.Count != 0)
        {
            foreach (int[] coord in thisCaptured)
            {
                int x = (coord[0] * 30) + 30;
                int y = (coord[1] * 30) + 30;
                await currentCanvasContext.ClearRectAsync(x, y, 20, 20);
            }
        }
    }

    async Task OnClick(MouseEventArgs eventArgs)
    {
        if (isLoadingOnClick)
        {
            return;
        }
        if (gameOver)
        {
            return;
        }
        isLoadingOnClick = true;
        double mouseX = 0;
        double mouseY = 0;
        if (divCanvas.Id?.Length > 0)
        {
            string data = await jsRuntime.InvokeAsync<string>("getDivCanvasOffsets", new object[] { divCanvas });
            JObject offsets = (JObject)JsonConvert.DeserializeObject(data);
            mouseX = eventArgs.ClientX - offsets.Value<double>("offsetLeft");
            mouseY = eventArgs.ClientY - offsets.Value<double>("offsetTop");

            if (stones != null && currentCanvasContext != null)
            {
                Move m = GetMove(mouseX, mouseY);
                if (m != null && IsLegalMove(m))
                {
                    whiteTurn = !whiteTurn;
                    await jsRuntime.InvokeAsync<string>("setTurnIsWhite", new object[] { whiteTurn });
                    await DrawStone(m);
                    await RemoveStones();
                }
            }
        }
        isLoadingOnClick = false;
    }
}
