@page "/localgame"
@page "/localgame/{dimensions}"
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using Newtonsoft.Json
@using Newtonsoft.Json.Linq
@using Shared.Models
@using System.Collections;
@inject IJSRuntime jsRuntime

<div class="turn-options inline">
    <div class="inline"><input @bind="turn" /></div>
    <button @onclick="SkipTurn" class="inline">Pass</button>
</div>
<div style="display: flex; justify-content: center; align-items: center; height: auto;">
    @if (dimensions.Equals("19"))
    {
        <div @ref="divCanvas" @onclick="@(async (MouseEventArgs m) => await OnClick(m))" class="board-canvas-19">
            <BECanvas @ref="stones" Height="620" Width="620"></BECanvas>
        </div>
    }
    @if (dimensions.Equals("13"))
    {
        <div @ref="divCanvas" @onclick="@(async (MouseEventArgs m) => await OnClick(m))" class="board-canvas-13">
            <BECanvas @ref="stones" Height="440" Width="440"></BECanvas>
        </div>
    }
    @if (dimensions.Equals("9"))
    {
        <div @ref="divCanvas" @onclick="@(async (MouseEventArgs m) => await OnClick(m))" class="board-canvas-9">
            <BECanvas @ref="stones" Height="320" Width="320"></BECanvas>
        </div>
    }
</div>
<div>
    <div class="inline">Black's Score: </div>
    <input class="inline" @bind="go.score[0]" />
</div>
<div>
    <div class="inline">White's Score: </div>
    <input class="inline" @bind="go.score[1]" />
</div>
<br>
<br>

@code {
    [Parameter]
    public String dimensions { get; set; }
    int dim;
    ElementReference divCanvas;
    Blazor.Extensions.BECanvasComponent stones;
    Canvas2DContext currentCanvasContext;
    List<Move> moves = new List<Move>();
    bool whiteTurn = false;
    String turn = "Black's Turn";
    ArrayList thisCaptured = new ArrayList();
    int passesInARow = 0;

    Board go = new Board(19);

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        dim = Int32.Parse(dimensions);
    }

    class Move
    {
        public int row;
        public int col;
        public bool isWhite;
    }

    async void SkipTurn()
    {
        passesInARow++;
        whiteTurn = !whiteTurn;
        if (whiteTurn)
        {
            turn = "White's Turn";
        }
        else
        {
            turn = "Black's Turn";
        }

        if (passesInARow >= 2)
        {
            go.setPlayable(false);
        }
    }

    Move GetMove(double mouseX, double mouseY)
    {
        for (int i = 0; i < dim; i++)
        {
            for (int j = 0; j < dim; j++)
            {
                int x = (i * 30) + 40;
                int y = (j * 30) + 40;
                if (mouseX < x + 10 && mouseX > x - 10 && mouseY < y + 10 && mouseY > y - 10)
                {
                    return new Move { row = i, col = j, isWhite = whiteTurn };
                }
            }
        }
        return null;
    }

    bool IsLegalMove(Move move)
    {
        int color = -1;
        if (go.getBlackToPlay())
        {
            color = 1;
        }
        ArrayList captured = go.playMove(new int[] { move.row, move.col, color });

        if (captured == null)
        {
            return false;
        }
        else
        {
            thisCaptured = captured;
            passesInARow = 0;
            return true;
        }
    }

    async Task DrawStone(Move move)
    {
        if (move.isWhite) await currentCanvasContext.SetFillStyleAsync("White");
        else await currentCanvasContext.SetFillStyleAsync("Black");
        await currentCanvasContext.BeginPathAsync();
        await currentCanvasContext.ArcAsync(move.row * 30 + 40, move.col * 30 + 40, 10, 0, 2 * Math.PI);
        await currentCanvasContext.ClosePathAsync();
        await currentCanvasContext.FillAsync();
    }

    async Task RemoveStones()
    {
        if (thisCaptured != null || thisCaptured.Count != 0)
        {
            foreach (int[] coord in thisCaptured)
            {
                int x = (coord[0] * 30) + 30;
                int y = (coord[1] * 30) + 30;
                await currentCanvasContext.ClearRectAsync(x, y, 20, 20);
            }
        }
    }

    async Task OnClick(MouseEventArgs eventArgs)
    {
        double mouseX = 0;
        double mouseY = 0;
        if (divCanvas.Id?.Length > 0)
        {
            string data = await jsRuntime.InvokeAsync<string>("getDivCanvasOffsets", new object[] { divCanvas });
            JObject offsets = (JObject)JsonConvert.DeserializeObject(data);
            mouseX = eventArgs.ClientX - offsets.Value<double>("offsetLeft");
            mouseY = eventArgs.ClientY - offsets.Value<double>("offsetTop");
            currentCanvasContext = await stones.CreateCanvas2DAsync();

            if (stones != null && currentCanvasContext != null)
            {
                Move m = GetMove(mouseX, mouseY);
                if (m != null && IsLegalMove(m))
                {
                    whiteTurn = !whiteTurn;
                    if (whiteTurn)
                    {
                        turn = "White's Turn";
                    }
                    else
                    {
                        turn = "Black's Turn";
                    }
                    await DrawStone(m);
                    await RemoveStones();
                }
            }

        }
    }
}
